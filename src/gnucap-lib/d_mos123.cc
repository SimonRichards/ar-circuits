
/* $Id: d_mos123.model,v 25.92 2006/06/28 15:02:53 al Exp $ -*- C++ -*-
 * Copyright (C) 2001 Albert Davis
 * Author: Albert Davis <aldavis@ieee.org>
 *
 * This file is part of "Gnucap", the Gnu Circuit Analysis Package
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 *------------------------------------------------------------------
 * MOS model - base for levels 1,2,3,6
 */
/* This file is automatically generated. DO NOT EDIT */
#include "ap.h"
#include "d_mos123.h"
/*--------------------------------------------------------------------------*/
const double NA(NOT_INPUT);
const double INF(BIGBIG);
/*--------------------------------------------------------------------------*/
int MODEL_MOS123::_count = 0;
/*--------------------------------------------------------------------------*/
SDP_MOS123::SDP_MOS123(const COMMON_COMPONENT* cc)
  :SDP_MOS_BASE(cc)
{
  assert(cc);
  const COMMON_MOS* c = prechecked_cast<const COMMON_MOS*>(cc);
  assert(c);
  const MODEL_MOS123* m = prechecked_cast<const MODEL_MOS123*>(c->model());
  assert(m);
  // adjust: override
    this->cgate = m->cox * w_eff * l_eff;
    this->phi = m->phi;
  // adjust: raw
  // adjust: calculated
  // code_post
}
/*--------------------------------------------------------------------------*/
TDP_MOS123::TDP_MOS123(const DEV_MOS* d)
  :TDP_MOS_BASE(d)
{
}
/*--------------------------------------------------------------------------*/
MODEL_MOS123::MODEL_MOS123()
  :MODEL_MOS_BASE(),
   vto_raw(NA),
   gamma(NA),
   phi(NA),
   lambda(NA),
   tox(NA),
   nsub_cm(NA),
   nss_cm(0.0),
   xj(NA),
   uo_cm(600.),
   tpg(gtOPP),
   nsub(NA),
   nss(NA),
   uo(NA),
   vto(NA),
   cox(NA),
   calc_vto(false),
   calc_gamma(false),
   calc_phi(false)
{
  ++_count;
  cjo = 0.;
  pb = 0.8;
  pbsw = NA;
}
/*--------------------------------------------------------------------------*/
bool MODEL_MOS123::parse_front(CS& cmd)
{
  return MODEL_MOS_BASE::parse_front(cmd);
}
/*--------------------------------------------------------------------------*/
bool MODEL_MOS123::parse_params(CS& cmd)
{
  return ONE_OF
    || get(cmd, "VTO", &vto_raw)
    || get(cmd, "GAmma", &gamma)
    || get(cmd, "PHI", &phi)
    || get(cmd, "LAmbda", &lambda)
    || get(cmd, "TOX", &tox)
    || get(cmd, "NSUb", &nsub_cm)
    || get(cmd, "NSS", &nss_cm)
    || get(cmd, "XJ", &xj)
    || get(cmd, "UO", &uo_cm)
    || get(cmd, "U0", &uo_cm)
    || get(cmd, "TPG", &tpg)
    || MODEL_MOS_BASE::parse_params(cmd)
    ;
}
/*--------------------------------------------------------------------------*/
void MODEL_MOS123::elabo1()
{
  if (1 || !evaluated()) {
    const CARD_LIST* par_scope = scope();
    assert(par_scope);
    MODEL_MOS_BASE::elabo1();
    // final adjust: code_pre

      {if (tpg < 0) {		// coerce tpg to a proper value
	tpg = gtSAME;		
      }else if (tpg > 0) {
	tpg = gtOPP;
      }else{
	assert(tpg == gtMETAL);
      }}
      if (tox != NA && tox <= 0) {
	untested();
	tox = NA;
	error(bWARNING, long_label()+": tox <= 0, treating as if not input\n");
      }
      if (nsub != NA && nsub < NI) {
	untested();
	nsub = NA;
	error(bWARNING,long_label()+": nsub < ni, treating as if not input\n");
      }
    // final adjust: override
    if (pbsw == NA) {
      pbsw = pb;
    }
    cmodel = ((!cmodel)?3:cmodel);
    // final adjust: raw
    this->vto_raw.e_val(NA, par_scope);
    this->gamma.e_val(NA, par_scope);
    this->phi.e_val(NA, par_scope);
    this->lambda.e_val(NA, par_scope);
    this->tox.e_val(NA, par_scope);
    this->nsub_cm.e_val(NA, par_scope);
    this->nss_cm.e_val(0.0, par_scope);
    this->xj.e_val(NA, par_scope);
    this->uo_cm.e_val(600., par_scope);
    this->tpg.e_val(gtOPP, par_scope);
    // final adjust: mid
    // final adjust: calculated
    nsub = ((nsub_cm.has_value()) ? nsub_cm*ICM2M3 : NA);
    nss = nss_cm*ICM2M2;
    uo = uo_cm*CM2M2;
    vto = ((vto_raw.has_value()) ? vto_raw * polarity : NA);
    // final adjust: post
    // final adjust: done
  }else{
    untested();
  }
}
/*--------------------------------------------------------------------------*/
SDP_CARD* MODEL_MOS123::new_sdp(const COMMON_COMPONENT* c)const
{
  assert(c);
  {if (dynamic_cast<const COMMON_MOS*>(c)) {
    return new SDP_MOS123(c);
  }else{
    return MODEL_MOS_BASE::new_sdp(c);
  }}
}
/*--------------------------------------------------------------------------*/
void MODEL_MOS123::print_front(OMSTREAM& o)const
{
  MODEL_MOS_BASE::print_front(o);
}
/*--------------------------------------------------------------------------*/
void MODEL_MOS123::print_params(OMSTREAM& o)const
{
  MODEL_MOS_BASE::print_params(o);
  if (!calc_vto)
    o << "  vto=" << vto_raw;
  if (!calc_gamma)
    o << "  gamma=" << gamma;
  if (!calc_phi)
    o << "  phi=" << phi;
  if (lambda != NA)
    o << "  lambda=" << lambda;
  if (tox != NA)
    o << "  tox=" << tox;
  if (nsub_cm != NA)
    o << "  nsub=" << nsub_cm;
  if (nss_cm != 0.0 || nsub_cm != NA)
    o << "  nss=" << nss_cm;
  if (xj != NA)
    o << "  xj=" << xj;
  o << "  uo=" << uo_cm;
  o << "  tpg=" << tpg;
}
/*--------------------------------------------------------------------------*/
void MODEL_MOS123::print_calculated(OMSTREAM& o)const
{
  MODEL_MOS_BASE::print_calculated(o);
  if (calc_gamma)
    o << "* gamma=" << gamma;
  if (calc_phi)
    o << "* phi=" << phi;
  if (calc_vto)
    o << "* vto=" << vto;
  if (true)
    o << "* cox=" << cox;
}
/*--------------------------------------------------------------------------*/
bool MODEL_MOS123::is_valid(const COMMON_COMPONENT* cc)const
{
  return MODEL_MOS_BASE::is_valid(cc);
}
/*--------------------------------------------------------------------------*/
void MODEL_MOS123::tr_eval(COMPONENT*)const
{
}
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
