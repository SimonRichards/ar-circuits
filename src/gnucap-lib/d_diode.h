/* $Id: d_diode.model,v 25.95 2006/08/26 01:23:57 al Exp $ -*- C++ -*-
 * Copyright (C) 2001 Albert Davis
 * Author: Albert Davis <aldavis@ieee.org>
 *
 * This file is part of "Gnucap", the Gnu Circuit Analysis Package
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 *------------------------------------------------------------------
 * diode model.
 * netlist syntax:
 * device:  dxxxx n+ n- mname <area> <off> <ic=vd> <model-card-args>
 * model:   .model mname D <args>
 *
 * The section "eval Yj" is a big mess.
 * It will be redone using multiple files, like the MOS models.
 */
/* This file is automatically generated. DO NOT EDIT */
#ifndef D_DIODE_H_INCLUDED
#define D_DIODE_H_INCLUDED

  enum region_t {INITOFF=-2, REVERSE=-1, UNKNOWN=0, FORWARD=1};
  enum polarity_t {pP = -1, pN = 1};
  class DEV_DIODE;
  class DEV_ADMITTANCE;
  class DEV_CAPACITANCE;
  class DEV_RESISTANCE;
#include "u_sdp.h"
#include "e_node.h"
#include "e_subckt.h"
#include "e_model.h"
/*--------------------------------------------------------------------------*/
class SDP_DIODE
  :public SDP_CARD{
public:
  explicit SDP_DIODE(const COMMON_COMPONENT*);
public:
};
/*--------------------------------------------------------------------------*/
class TDP_DIODE{
public:
  explicit TDP_DIODE(const DEV_DIODE*);
public:
};
/*--------------------------------------------------------------------------*/
class MODEL_DIODE
  :public MODEL_CARD{
public:
  // using generated copy constructor, should be unreachable
  explicit MODEL_DIODE();
  ~MODEL_DIODE() {--_count;}
public: // override virtual
  bool      parse_front(CS&);
  bool      parse_params(CS&);
  void      elabo1();
  SDP_CARD* new_sdp(const COMMON_COMPONENT* c)const;
  void      print_front(OMSTREAM&)const;
  void      print_params(OMSTREAM&)const;
  void      print_calculated(OMSTREAM&)const;
  bool      is_valid(const COMMON_COMPONENT*)const;
  void      tr_eval(COMPONENT*)const;
public: // not virtual
  static int count() {return _count;}
private: // strictly internal
  static int _count;
public: // input parameters
  PARAMETER<double> js;	// = is, saturation current (per area)
  PARAMETER<double> rs;	// ohmic resistance (per area)
  PARAMETER<double> n_factor;	// emission coefficient
  PARAMETER<double> tt;	// transit time
  PARAMETER<double> cjo;	// cj, zero-bias jct capacitance (per area)
  PARAMETER<double> pb;	// vj, junction potential
  PARAMETER<double> mj;	// m, grading coefficient
  PARAMETER<double> eg;	// activation energy
  PARAMETER<double> xti;	// saturation-current temp. exp.
  PARAMETER<double> kf;	// flicker noise coefficient
  PARAMETER<double> af;	// flicker noise exponent
  PARAMETER<double> fc;	// coef for fwd bias depl cap formula
  PARAMETER<double> bv;	// reverse breakdown voltage
  PARAMETER<double> ibv;	// current at reverse breakdown
  PARAMETER<double> cjsw;	// zero bias sidewall cap (per perim.)
  PARAMETER<double> pbsw;	// sidewall junction potential
  PARAMETER<double> mjsw;	// sidewall grading coefficient
  PARAMETER<double> gparallel;	// parallel conductance
  PARAMETER<OCTAL> flags;	// 
  PARAMETER<int> mos_level;	// 
public: // calculated parameters
};
/*--------------------------------------------------------------------------*/
class COMMON_DIODE
  :public COMMON_COMPONENT{
public:
  explicit COMMON_DIODE(const COMMON_DIODE& p);
  explicit COMMON_DIODE(int c=0);
           ~COMMON_DIODE();
  bool        operator==(const COMMON_COMPONENT&)const;
  COMMON_COMPONENT* clone()const {return new COMMON_DIODE(*this);}
  void        parse(CS&);
  void        print(OMSTREAM&)const;
  void        elabo3(const COMPONENT*);
  const char* name()const {return "diode";}
  const SDP_CARD* sdp()const {return _sdp;}
  bool      has_sdp()const {return _sdp;}
  static int  count() {return _count;}
private: // strictly internal
  static int _count;
public: // input parameters
  PARAMETER<double> area;	// area factor
  PARAMETER<double> perim;	// perimeter factor
  PARAMETER<double> m;	// device multiplier
  PARAMETER<bool> off;	// flag: assume reverse biased
  PARAMETER<double> ic;	// initial voltage
  PARAMETER<double> is_raw;	// saturation current
  PARAMETER<double> rs_raw;	// series resistance
  PARAMETER<double> cj_raw;	// zero bias jct capacitance
  PARAMETER<double> cjsw_raw;	// zero bias sidewall capacitance
  PARAMETER<double> gparallel_raw;	// parallel conductance
public: // calculated parameters
  const SDP_CARD* _sdp;
  double is_adjusted;	// 
  double rs_adjusted;	// 
  double cj_adjusted;	// 
  double cjsw_adjusted;	// 
  double gparallel_adjusted;	// 
public: // attached commons
};
/*--------------------------------------------------------------------------*/
class EVAL_DIODE_Cj : public COMMON_COMPONENT {
private:
  explicit EVAL_DIODE_Cj(const EVAL_DIODE_Cj& p)
    :COMMON_COMPONENT(p) {}
public:
  explicit EVAL_DIODE_Cj(int c=0) :COMMON_COMPONENT(c) {}
  bool operator==(const COMMON_COMPONENT& x)const {return COMMON_COMPONENT::operator==(x);}
  COMMON_COMPONENT* clone()const {return new EVAL_DIODE_Cj(*this);}
  const char* name()const {untested(); return "EVAL_DIODE_Cj";}
  void tr_eval(ELEMENT*d)const;
  bool has_tr_eval()const {return true;}
  bool has_ac_eval()const {return false;}
};
/*--------------------------------------------------------------------------*/
class EVAL_DIODE_Yj : public COMMON_COMPONENT {
private:
  explicit EVAL_DIODE_Yj(const EVAL_DIODE_Yj& p)
    :COMMON_COMPONENT(p) {}
public:
  explicit EVAL_DIODE_Yj(int c=0) :COMMON_COMPONENT(c) {}
  bool operator==(const COMMON_COMPONENT& x)const {return COMMON_COMPONENT::operator==(x);}
  COMMON_COMPONENT* clone()const {return new EVAL_DIODE_Yj(*this);}
  const char* name()const {untested(); return "EVAL_DIODE_Yj";}
  void tr_eval(ELEMENT*d)const;
  bool has_tr_eval()const {return true;}
  bool has_ac_eval()const {return false;}
};
/*--------------------------------------------------------------------------*/
class DEV_DIODE : public BASE_SUBCKT {
private:
  explicit DEV_DIODE(const DEV_DIODE& p);
public:
  explicit DEV_DIODE();
           ~DEV_DIODE() {--_count;}
private: // override virtual
  char      id_letter()const     {return 'D';}
  const char* dev_type()const    {return "diode";}
  int       max_nodes()const     {return 2;}
  int       min_nodes()const     {return 2;}
  int       out_nodes()const     {return 2;}
  //int     matrix_nodes()const; //BASE_SUBCKT
  int       net_nodes()const     {return 2;}
  int       int_nodes()const     {return 1;}
  CARD*     clone()const         {return new DEV_DIODE(*this);}
  //void    parse_spice(CS&);    //BASE_SUBCKT
  //void    print_spice(OMSTREAM&,int)const; //BASE_SUBCKT
  void      elabo1();
  //void    map_nodes();         //BASE_SUBCKT
  //void    precalc();           //BASE_SUBCKT
  //void    dc_begin();          //BASE_SUBCKT
  //void    tr_begin();          //BASE_SUBCKT
  //void    tr_restore();        //BASE_SUBCKT
  //void    dc_advance();        //BASE_SUBCKT
  //void    tr_advance();        //BASE_SUBCKT
  //bool    tr_needs_eval()const;//BASE_SUBCKT
  //void    tr_queue_eval();     //BASE_SUBCKT
  //bool    do_tr();             //BASE_SUBCKT
  //void    tr_load();           //BASE_SUBCKT
  //double  tr_review();         //BASE_SUBCKT
  //void    tr_accept();         //BASE_SUBCKT
  //void    tr_unload();         //BASE_SUBCKT
  double    tr_probe_num(CS&)const;
  //void    ac_begin();          //BASE_SUBCKT
  //void    do_ac();             //BASE_SUBCKT
  //void    ac_load();           //BASE_SUBCKT
  //XPROBE  ac_probe_ext(CS&)const;//CKT_BASE/nothing
public:
  static int  count() {return _count;}
public: // may be used by models
private: // not available even to models
  static int _count;
public: // input parameters
public: // calculated parameters
  region_t _region;	// fwd, reverse, unknown
  double _gd;	// conductance to pass to capacitor
  double _isat;	// is adjusted for temp, etc.
public: // netlist
  DEV_CAPACITANCE* _Cj;
  DEV_ADMITTANCE* _Yj;
  DEV_RESISTANCE* _Rs;
private: // node list
  enum {n_anode=0, n_cathode=1, n_ianode=-1};
  node_t _nodes[3];
};
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
#endif
